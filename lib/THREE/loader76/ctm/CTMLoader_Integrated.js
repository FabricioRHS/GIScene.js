/**
 * Loader for CTM encoded models generated by OpenCTM tools:
 *	http://openctm.sourceforge.net/
 *
 * Uses js-openctm library by Juan Mellado
 *	http://code.google.com/p/js-openctm/
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CTMLoader = function () {

	THREE.Loader.call( this );

	// Deprecated
	
	Object.defineProperties( this, {
		statusDomElement: {
			get: function () {

				if ( this._statusDomElement === undefined ) {

					this._statusDomElement = document.createElement( 'div' );

				}

				console.warn( 'THREE.BinaryLoader: .statusDomElement has been removed.' );
				return this._statusDomElement;

			}
		},
	} );

};

THREE.CTMLoader.prototype = Object.create( THREE.Loader.prototype );
THREE.CTMLoader.prototype.constructor = THREE.CTMLoader;

// Load multiple CTM parts defined in JSON

THREE.CTMLoader.prototype.loadParts = function( url, callback, parameters ) {

	parameters = parameters || {};

	var scope = this;

	var xhr = new XMLHttpRequest();

	var basePath = parameters.basePath ? parameters.basePath : this.extractUrlBase( url );

	xhr.onreadystatechange = function() {

		if ( xhr.readyState === 4 ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				var jsonObject = JSON.parse( xhr.responseText );

				var materials = [], geometries = [], counter = 0;

				function callbackFinal( geometry ) {

					counter += 1;

					geometries.push( geometry );

					if ( counter === jsonObject.offsets.length ) {

						callback( geometries, materials );

					}

				}


				// init materials

				for ( var i = 0; i < jsonObject.materials.length; i ++ ) {

					materials[ i ] = scope.createMaterial( jsonObject.materials[ i ], basePath );

				}

				// load joined CTM file

				var partUrl = basePath + jsonObject.data;
				var parametersPart = { useWorker: parameters.useWorker, offsets: jsonObject.offsets };
				scope.load( partUrl, callbackFinal, parametersPart );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.setRequestHeader( "Content-Type", "text/plain" );
	xhr.send( null );

};

// Load CTMLoader compressed models
//	- parameters
//		- url (required)
//		- callback (required)

THREE.CTMLoader.prototype.load = function( url, callback, parameters ) {

	parameters = parameters || {};

	var scope = this;

	var offsets = parameters.offsets !== undefined ? parameters.offsets : [ 0 ];

	var xhr = new XMLHttpRequest(),
		callbackProgress = null;

	var length = 0;

	xhr.onreadystatechange = function() {

		if ( xhr.readyState === 4 ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				var binaryData = new Uint8Array(xhr.response);

				var s = Date.now();

				if ( parameters.useWorker ) {

					// var worker = parameters.worker || new Worker( "js/loaders/ctm/CTMWorker.js" );
					var worker = new Worker( window.URL.createObjectURL(new Blob([THREE.CTMLoader.workerString], {type: "text/javascript"})));

					worker.onmessage = function( event ) {

						var files = event.data;

						for ( var i = 0; i < files.length; i ++ ) {

							var ctmFile = files[ i ];

							var e1 = Date.now();
							// console.log( "CTM data parse time [worker]: " + (e1-s) + " ms" );

							scope.createModel( ctmFile, callback );

							var e = Date.now();
							console.log( "model load time [worker]: " + (e - e1) + " ms, total: " + (e - s));

						}


					};

					worker.postMessage( { "data": binaryData, "offsets": offsets } );

				} else {

					for ( var i = 0; i < offsets.length; i ++ ) {

						var stream = new CTM.Stream( binaryData );
						stream.offset = offsets[ i ];

						var ctmFile = new CTM.File( stream );

						scope.createModel( ctmFile, callback );

					}

					//var e = Date.now();
					//console.log( "CTM data parse time [inline]: " + (e-s) + " ms" );

				}

			} else {

				console.error( "Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		} else if ( xhr.readyState === 3 ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( "Content-Length" );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === 2 ) {

			length = xhr.getResponseHeader( "Content-Length" );

		}

	};

	xhr.open( "GET", url, true );
	xhr.responseType = "arraybuffer";

	xhr.send( null );

};


THREE.CTMLoader.prototype.createModel = function ( file, callback ) {

	var Model = function () {

		THREE.BufferGeometry.call( this );

		this.materials = [];

		var indices = file.body.indices,
		positions = file.body.vertices,
		normals = file.body.normals;

		var uvs, colors;

		var uvMaps = file.body.uvMaps;

		if ( uvMaps !== undefined && uvMaps.length > 0 ) {

			uvs = uvMaps[ 0 ].uv;

		}

		var attrMaps = file.body.attrMaps;

		if ( attrMaps !== undefined && attrMaps.length > 0 && attrMaps[ 0 ].name === 'Color' ) {

			colors = attrMaps[ 0 ].attr;

		}

		this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		if ( normals !== undefined ) {

			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

		}

		if ( uvs !== undefined ) {

			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		}

		if ( colors !== undefined ) {

			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 4 ) );

		}

	};

	Model.prototype = Object.create( THREE.BufferGeometry.prototype );
	Model.prototype.constructor = Model;

	var geometry = new Model();

	// compute vertex normals if not present in the CTM model
	if ( geometry.attributes.normal === undefined ) {
		geometry.computeVertexNormals();
	}

	callback( geometry );

};

THREE.CTMLoader.workerString = 
	//importScripts( "lzma.js", "ctm.js" );
	
	//lzma.js"
	
	"var LZMA = LZMA || {};\n"+
	
	"LZMA.OutWindow = function(){\n"+
	"  this._windowSize = 0;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.create = function(windowSize){\n"+
	"  if ( (!this._buffer) || (this._windowSize !== windowSize) ){\n"+
	"    this._buffer = [];\n"+
	"  }\n"+
	"  this._windowSize = windowSize;\n"+
	"  this._pos = 0;\n"+
	"  this._streamPos = 0;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.flush = function(){\n"+
	"  var size = this._pos - this._streamPos;\n"+
	"  if (size !== 0){\n"+
	"    while(size --){\n"+
	"      this._stream.writeByte(this._buffer[this._streamPos ++]);\n"+
	"    }\n"+
	"    if (this._pos >= this._windowSize){\n"+
	"      this._pos = 0;\n"+
	"    }\n"+
	"    this._streamPos = this._pos;\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.releaseStream = function(){\n"+
	"  this.flush();\n"+
	"  this._stream = null;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.setStream = function(stream){\n"+
	"  this.releaseStream();\n"+
	"  this._stream = stream;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.init = function(solid){\n"+
	"  if (!solid){\n"+
	"    this._streamPos = 0;\n"+
	"    this._pos = 0;\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.copyBlock = function(distance, len){\n"+
	"  var pos = this._pos - distance - 1;\n"+
	"  if (pos < 0){\n"+
	"    pos += this._windowSize;\n"+
	"  }\n"+
	"  while(len --){\n"+
	"    if (pos >= this._windowSize){\n"+
	"      pos = 0;\n"+
	"    }\n"+
	"    this._buffer[this._pos ++] = this._buffer[pos ++];\n"+
	"    if (this._pos >= this._windowSize){\n"+
	"      this.flush();\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.putByte = function(b){\n"+
	"  this._buffer[this._pos ++] = b;\n"+
	"  if (this._pos >= this._windowSize){\n"+
	"    this.flush();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.getByte = function(distance){\n"+
	"  var pos = this._pos - distance - 1;\n"+
	"  if (pos < 0){\n"+
	"    pos += this._windowSize;\n"+
	"  }\n"+
	"  return this._buffer[pos];\n"+
	"};\n"+
	
	"LZMA.RangeDecoder = function(){\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.setStream = function(stream){\n"+
	"  this._stream = stream;\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.releaseStream = function(){\n"+
	"  this._stream = null;\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.init = function(){\n"+
	"  var i = 5;\n"+
	
	"  this._code = 0;\n"+
	"  this._range = -1;\n"+
	"  \n"+
	"  while(i --){\n"+
	"    this._code = (this._code << 8) | this._stream.readByte();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){\n"+
	"  var result = 0, i = numTotalBits, t;\n"+
	
	"  while(i --){\n"+
	"    this._range >>>= 1;\n"+
	"    t = (this._code - this._range) >>> 31;\n"+
	"    this._code -= this._range & (t - 1);\n"+
	"    result = (result << 1) | (1 - t);\n"+
	
	"    if ( (this._range & 0xff000000) === 0){\n"+
	"      this._code = (this._code << 8) | this._stream.readByte();\n"+
	"      this._range <<= 8;\n"+
	"    }\n"+
	"  }\n"+
	
	"  return result;\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.decodeBit = function(probs, index){\n"+
	"  var prob = probs[index],\n"+
	"      newBound = (this._range >>> 11) * prob;\n"+
	
	"  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){\n"+
	"    this._range = newBound;\n"+
	"    probs[index] += (2048 - prob) >>> 5;\n"+
	"    if ( (this._range & 0xff000000) === 0){\n"+
	"      this._code = (this._code << 8) | this._stream.readByte();\n"+
	"      this._range <<= 8;\n"+
	"    }\n"+
	"    return 0;\n"+
	"  }\n"+
	
	"  this._range -= newBound;\n"+
	"  this._code -= newBound;\n"+
	"  probs[index] -= prob >>> 5;\n"+
	"  if ( (this._range & 0xff000000) === 0){\n"+
	"    this._code = (this._code << 8) | this._stream.readByte();\n"+
	"    this._range <<= 8;\n"+
	"  }\n"+
	"  return 1;\n"+
	"};\n"+
	
	"LZMA.initBitModels = function(probs, len){\n"+
	"  while(len --){\n"+
	"    probs[len] = 1024;\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder = function(numBitLevels){\n"+
	"  this._models = [];\n"+
	"  this._numBitLevels = numBitLevels;\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder.prototype.init = function(){\n"+
	"  LZMA.initBitModels(this._models, 1 << this._numBitLevels);\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){\n"+
	"  var m = 1, i = this._numBitLevels;\n"+
	
	"  while(i --){\n"+
	"    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);\n"+
	"  }\n"+
	"  return m - (1 << this._numBitLevels);\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){\n"+
	"  var m = 1, symbol = 0, i = 0, bit;\n"+
	
	"  for (; i < this._numBitLevels; ++ i){\n"+
	"    bit = rangeDecoder.decodeBit(this._models, m);\n"+
	"    m = (m << 1) | bit;\n"+
	"    symbol |= bit << i;\n"+
	"  }\n"+
	"  return symbol;\n"+
	"};\n"+
	
	"LZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){\n"+
	"  var m = 1, symbol = 0, i = 0, bit;\n"+
	
	"  for (; i < numBitLevels; ++ i){\n"+
	"    bit = rangeDecoder.decodeBit(models, startIndex + m);\n"+
	"    m = (m << 1) | bit;\n"+
	"    symbol |= bit << i;\n"+
	"  }\n"+
	"  return symbol;\n"+
	"};\n"+
	
	"LZMA.LenDecoder = function(){\n"+
	"  this._choice = [];\n"+
	"  this._lowCoder = [];\n"+
	"  this._midCoder = [];\n"+
	"  this._highCoder = new LZMA.BitTreeDecoder(8);\n"+
	"  this._numPosStates = 0;\n"+
	"};\n"+
	
	"LZMA.LenDecoder.prototype.create = function(numPosStates){\n"+
	"  for (; this._numPosStates < numPosStates; ++ this._numPosStates){\n"+
	"    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n"+
	"    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.LenDecoder.prototype.init = function(){\n"+
	"  var i = this._numPosStates;\n"+
	"  LZMA.initBitModels(this._choice, 2);\n"+
	"  while(i --){\n"+
	"    this._lowCoder[i].init();\n"+
	"    this._midCoder[i].init();\n"+
	"  }\n"+
	"  this._highCoder.init();\n"+
	"};\n"+
	
	"LZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){\n"+
	"  if (rangeDecoder.decodeBit(this._choice, 0) === 0){\n"+
	"    return this._lowCoder[posState].decode(rangeDecoder);\n"+
	"  }\n"+
	"  if (rangeDecoder.decodeBit(this._choice, 1) === 0){\n"+
	"    return 8 + this._midCoder[posState].decode(rangeDecoder);\n"+
	"  }\n"+
	"  return 16 + this._highCoder.decode(rangeDecoder);\n"+
	"};\n"+
	
	"LZMA.Decoder2 = function(){\n"+
	"  this._decoders = [];\n"+
	"};\n"+
	
	"LZMA.Decoder2.prototype.init = function(){\n"+
	"  LZMA.initBitModels(this._decoders, 0x300);\n"+
	"};\n"+
	
	"LZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){\n"+
	"  var symbol = 1;\n"+
	
	"  do{\n"+
	"    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n"+
	"  }while(symbol < 0x100);\n"+
	
	"  return symbol & 0xff;\n"+
	"};\n"+
	
	"LZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){\n"+
	"  var symbol = 1, matchBit, bit;\n"+
	
	"  do{\n"+
	"    matchBit = (matchByte >> 7) & 1;\n"+
	"    matchByte <<= 1;\n"+
	"    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);\n"+
	"    symbol = (symbol << 1) | bit;\n"+
	"    if (matchBit !== bit){\n"+
	"      while(symbol < 0x100){\n"+
	"        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n"+
	"      }\n"+
	"      break;\n"+
	"    }\n"+
	"  }while(symbol < 0x100);\n"+
	
	"  return symbol & 0xff;\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder = function(){\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){\n"+
	"  var i;\n"+
	
	"  if (this._coders\n"+
	"    && (this._numPrevBits === numPrevBits)\n"+
	"    && (this._numPosBits === numPosBits) ){\n"+
	"    return;\n"+
	"  }\n"+
	"  this._numPosBits = numPosBits;\n"+
	"  this._posMask = (1 << numPosBits) - 1;\n"+
	"  this._numPrevBits = numPrevBits;\n"+
	
	"  this._coders = [];\n"+
	
	"  i = 1 << (this._numPrevBits + this._numPosBits);\n"+
	"  while(i --){\n"+
	"    this._coders[i] = new LZMA.Decoder2();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder.prototype.init = function(){\n"+
	"  var i = 1 << (this._numPrevBits + this._numPosBits);\n"+
	"  while(i --){\n"+
	"    this._coders[i].init();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){\n"+
	"  return this._coders[( (pos & this._posMask) << this._numPrevBits)\n"+
	"    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];\n"+
	"};\n"+
	
	"LZMA.Decoder = function(){\n"+
	"  this._outWindow = new LZMA.OutWindow();\n"+
	"  this._rangeDecoder = new LZMA.RangeDecoder();\n"+
	"  this._isMatchDecoders = [];\n"+
	"  this._isRepDecoders = [];\n"+
	"  this._isRepG0Decoders = [];\n"+
	"  this._isRepG1Decoders = [];\n"+
	"  this._isRepG2Decoders = [];\n"+
	"  this._isRep0LongDecoders = [];\n"+
	"  this._posSlotDecoder = [];\n"+
	"  this._posDecoders = [];\n"+
	"  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);\n"+
	"  this._lenDecoder = new LZMA.LenDecoder();\n"+
	"  this._repLenDecoder = new LZMA.LenDecoder();\n"+
	"  this._literalDecoder = new LZMA.LiteralDecoder();\n"+
	"  this._dictionarySize = -1;\n"+
	"  this._dictionarySizeCheck = -1;\n"+
	
	"  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);\n"+
	"  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);\n"+
	"  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);\n"+
	"  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){\n"+
	"  if (dictionarySize < 0){\n"+
	"    return false;\n"+
	"  }\n"+
	"  if (this._dictionarySize !== dictionarySize){\n"+
	"    this._dictionarySize = dictionarySize;\n"+
	"    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);\n"+
	"    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );\n"+
	"  }\n"+
	"  return true;\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){\n"+
	"  var numPosStates = 1 << pb;\n"+
	
	"  if (lc > 8 || lp > 4 || pb > 4){\n"+
	"    return false;\n"+
	"  }\n"+
	
	"  this._literalDecoder.create(lp, lc);\n"+
	
	"  this._lenDecoder.create(numPosStates);\n"+
	"  this._repLenDecoder.create(numPosStates);\n"+
	"  this._posStateMask = numPosStates - 1;\n"+
	
	"  return true;\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.init = function(){\n"+
	"  var i = 4;\n"+
	
	"  this._outWindow.init(false);\n"+
	
	"  LZMA.initBitModels(this._isMatchDecoders, 192);\n"+
	"  LZMA.initBitModels(this._isRep0LongDecoders, 192);\n"+
	"  LZMA.initBitModels(this._isRepDecoders, 12);\n"+
	"  LZMA.initBitModels(this._isRepG0Decoders, 12);\n"+
	"  LZMA.initBitModels(this._isRepG1Decoders, 12);\n"+
	"  LZMA.initBitModels(this._isRepG2Decoders, 12);\n"+
	"  LZMA.initBitModels(this._posDecoders, 114);\n"+
	
	"  this._literalDecoder.init();\n"+
	
	"  while(i --){\n"+
	"    this._posSlotDecoder[i].init();\n"+
	"  }\n"+
	
	"  this._lenDecoder.init();\n"+
	"  this._repLenDecoder.init();\n"+
	"  this._posAlignDecoder.init();\n"+
	"  this._rangeDecoder.init();\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){\n"+
	"  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,\n"+
	"      posState, decoder2, len, distance, posSlot, numDirectBits;\n"+
	
	"  this._rangeDecoder.setStream(inStream);\n"+
	"  this._outWindow.setStream(outStream);\n"+
	
	"  this.init();\n"+
	
	"  while(outSize < 0 || nowPos64 < outSize){\n"+
	"    posState = nowPos64 & this._posStateMask;\n"+
	
	"    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){\n"+
	"      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);\n"+
	
	"      if (state >= 7){\n"+
	"        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );\n"+
	"      }else{\n"+
	"        prevByte = decoder2.decodeNormal(this._rangeDecoder);\n"+
	"      }\n"+
	"      this._outWindow.putByte(prevByte);\n"+
	
	"      state = state < 4? 0: state - (state < 10? 3: 6);\n"+
	
	"    }else{\n"+
	
	"      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){\n"+
	"        len = 0;\n"+
	"        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){\n"+
	"          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){\n"+
	"            state = state < 7? 9: 11;\n"+
	"            len = 1;\n"+
	"          }\n"+
	"        }else{\n"+
	"          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){\n"+
	"            distance = rep1;\n"+
	"          }else{\n"+
	"            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){\n"+
	"              distance = rep2;\n"+
	"            }else{\n"+
	"              distance = rep3;\n"+
	"              rep3 = rep2;\n"+
	"            }\n"+
	"            rep2 = rep1;\n"+
	"          }\n"+
	"          rep1 = rep0;\n"+
	"          rep0 = distance;\n"+
	"        }\n"+
	"        if (len === 0){\n"+
	"          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);\n"+
	"          state = state < 7? 8: 11;\n"+
	"        }\n"+
	"      }else{\n"+
	"        rep3 = rep2;\n"+
	"        rep2 = rep1;\n"+
	"        rep1 = rep0;\n"+
	
	"        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);\n"+
	"        state = state < 7? 7: 10;\n"+
	
	"        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);\n"+
	"        if (posSlot >= 4){\n"+
	
	"          numDirectBits = (posSlot >> 1) - 1;\n"+
	"          rep0 = (2 | (posSlot & 1) ) << numDirectBits;\n"+
	
	"          if (posSlot < 14){\n"+
	"            rep0 += LZMA.reverseDecode2(this._posDecoders,\n"+
	"                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);\n"+
	"          }else{\n"+
	"            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;\n"+
	"            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);\n"+
	"            if (rep0 < 0){\n"+
	"              if (rep0 === -1){\n"+
	"                break;\n"+
	"              }\n"+
	"              return false;\n"+
	"            }\n"+
	"          }\n"+
	"        }else{\n"+
	"          rep0 = posSlot;\n"+
	"        }\n"+
	"      }\n"+
	
	"      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){\n"+
	"        return false;\n"+
	"      }\n"+
	
	"      this._outWindow.copyBlock(rep0, len);\n"+
	"      nowPos64 += len;\n"+
	"      prevByte = this._outWindow.getByte(0);\n"+
	"    }\n"+
	"  }\n"+
	
	"  this._outWindow.flush();\n"+
	"  this._outWindow.releaseStream();\n"+
	"  this._rangeDecoder.releaseStream();\n"+
	
	"  return true;\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.setDecoderProperties = function(properties){\n"+
	"  var value, lc, lp, pb, dictionarySize;\n"+
	
	"  if (properties.size < 5){\n"+
	"    return false;\n"+
	"  }\n"+
	
	"  value = properties.readByte();\n"+
	"  lc = value % 9;\n"+
	"  value = ~~(value / 9);\n"+
	"  lp = value % 5;\n"+
	"  pb = ~~(value / 5);\n"+
	
	"  if ( !this.setLcLpPb(lc, lp, pb) ){\n"+
	"    return false;\n"+
	"  }\n"+
	
	"  dictionarySize = properties.readByte();\n"+
	"  dictionarySize |= properties.readByte() << 8;\n"+
	"  dictionarySize |= properties.readByte() << 16;\n"+
	"  dictionarySize += properties.readByte() * 16777216;\n"+
	
	"  return this.setDictionarySize(dictionarySize);\n"+
	"};\n"+
	
	"LZMA.decompress = function(properties, inStream, outStream, outSize){\n"+
	"  var decoder = new LZMA.Decoder();\n"+
	
	"  if ( !decoder.setDecoderProperties(properties) ){\n"+
	"    throw 'Incorrect stream properties';\n"+
	"  }\n"+
	
	"  if ( !decoder.decode(inStream, outStream, outSize) ){\n"+
	"    throw 'Error in data stream';\n"+
	"  }\n"+
	
	"  return true;\n"+
	"};\n"+
	
	//ctm.js
	
	"var CTM = CTM || {};\n"+
	
	"CTM.CompressionMethod = {\n"+
	"  RAW: 0x00574152,\n"+
	"  MG1: 0x0031474d,\n"+
	"  MG2: 0x0032474d\n"+
	"};\n"+
	
	"CTM.Flags = {\n"+
	"  NORMALS: 0x00000001\n"+
	"};\n"+
	
	"CTM.File = function(stream){\n"+
	"  this.load(stream);\n"+
	"};\n"+
	
	"CTM.File.prototype.load = function(stream){\n"+
	"  this.header = new CTM.FileHeader(stream);\n"+
	
	"  this.body = new CTM.FileBody(this.header);\n"+
	"  \n"+
	"  this.getReader().read(stream, this.body);\n"+
	"};\n"+
	
	"CTM.File.prototype.getReader = function(){\n"+
	"  var reader;\n"+
	
	"  switch(this.header.compressionMethod){\n"+
	"    case CTM.CompressionMethod.RAW:\n"+
	"      reader = new CTM.ReaderRAW();\n"+
	"      break;\n"+
	"    case CTM.CompressionMethod.MG1:\n"+
	"      reader = new CTM.ReaderMG1();\n"+
	"      break;\n"+
	"    case CTM.CompressionMethod.MG2:\n"+
	"      reader = new CTM.ReaderMG2();\n"+
	"      break;\n"+
	"  }\n"+
	
	"  return reader;\n"+
	"};\n"+
	
	"CTM.FileHeader = function(stream){\n"+
	//magic "OCTM"
	"  stream.readInt32(); \n"+
	"  this.fileFormat = stream.readInt32();\n"+
	"  this.compressionMethod = stream.readInt32();\n"+
	"  this.vertexCount = stream.readInt32();\n"+
	"  this.triangleCount = stream.readInt32();\n"+
	"  this.uvMapCount = stream.readInt32();\n"+
	"  this.attrMapCount = stream.readInt32();\n"+
	"  this.flags = stream.readInt32();\n"+
	"  this.comment = stream.readString();\n"+
	"};\n"+
	
	"CTM.FileHeader.prototype.hasNormals = function(){\n"+
	"  return this.flags & CTM.Flags.NORMALS;\n"+
	"};\n"+
	
	"CTM.FileBody = function(header){\n"+
	"  var i = header.triangleCount * 3,\n"+
	"      v = header.vertexCount * 3,\n"+
	"      n = header.hasNormals()? header.vertexCount * 3: 0,\n"+
	"      u = header.vertexCount * 2,\n"+
	"      a = header.vertexCount * 4,\n"+
	"      j = 0;\n"+
	
	"  var data = new ArrayBuffer(\n"+
	"    (i + v + n + (u * header.uvMapCount) + (a * header.attrMapCount) ) * 4);\n"+
	
	"  this.indices = new Uint32Array(data, 0, i);\n"+
	
	"  this.vertices = new Float32Array(data, i * 4, v);\n"+
	
	"  if ( header.hasNormals() ){\n"+
	"    this.normals = new Float32Array(data, (i + v) * 4, n);\n"+
	"  }\n"+
	"  \n"+
	"  if (header.uvMapCount){\n"+
	"    this.uvMaps = [];\n"+
	"    for (j = 0; j < header.uvMapCount; ++ j){\n"+
	"      this.uvMaps[j] = {uv: new Float32Array(data,\n"+
	"        (i + v + n + (j * u) ) * 4, u) };\n"+
	"    }\n"+
	"  }\n"+
	"  \n"+
	"  if (header.attrMapCount){\n"+
	"    this.attrMaps = [];\n"+
	"    for (j = 0; j < header.attrMapCount; ++ j){\n"+
	"      this.attrMaps[j] = {attr: new Float32Array(data,\n"+
	"        (i + v + n + (u * header.uvMapCount) + (j * a) ) * 4, a),start:(i + v + n + (u * header.uvMapCount) + (j * a) ) * 4 ,end:a };\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.FileMG2Header = function(stream){\n"+
	//magic "MG2H"
	"  stream.readInt32(); \n"+
	"  this.vertexPrecision = stream.readFloat32();\n"+
	"  this.normalPrecision = stream.readFloat32();\n"+
	"  this.lowerBoundx = stream.readFloat32();\n"+
	"  this.lowerBoundy = stream.readFloat32();\n"+
	"  this.lowerBoundz = stream.readFloat32();\n"+
	"  this.higherBoundx = stream.readFloat32();\n"+
	"  this.higherBoundy = stream.readFloat32();\n"+
	"  this.higherBoundz = stream.readFloat32();\n"+
	"  this.divx = stream.readInt32();\n"+
	"  this.divy = stream.readInt32();\n"+
	"  this.divz = stream.readInt32();\n"+
	"  \n"+
	"  this.sizex = (this.higherBoundx - this.lowerBoundx) / this.divx;\n"+
	"  this.sizey = (this.higherBoundy - this.lowerBoundy) / this.divy;\n"+
	"  this.sizez = (this.higherBoundz - this.lowerBoundz) / this.divz;\n"+
	"};\n"+
	
	"CTM.ReaderRAW = function(){\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.read = function(stream, body){\n"+
	"  this.readIndices(stream, body.indices);\n"+
	"  this.readVertices(stream, body.vertices);\n"+
	"  \n"+
	"  if (body.normals){\n"+
	"    this.readNormals(stream, body.normals);\n"+
	"  }\n"+
	"  if (body.uvMaps){\n"+
	"    this.readUVMaps(stream, body.uvMaps);\n"+
	"  }\n"+
	"  if (body.attrMaps){\n"+
	"    this.readAttrMaps(stream, body.attrMaps);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readIndices = function(stream, indices){\n"+
	//magic "INDX"
	"  stream.readInt32(); \n"+
	"  stream.readArrayInt32(indices);\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readVertices = function(stream, vertices){\n"+
	//magic "VERT"
	"  stream.readInt32(); \n"+
	"  stream.readArrayFloat32(vertices);\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readNormals = function(stream, normals){\n"+
	//magic "NORM"
	"  stream.readInt32(); \n"+
	"  stream.readArrayFloat32(normals);\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readUVMaps = function(stream, uvMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < uvMaps.length; ++ i){\n"+
	//magic "TEXC"
	"    stream.readInt32(); \n"+
	
	"    uvMaps[i].name = stream.readString();\n"+
	"    uvMaps[i].filename = stream.readString();\n"+
	"    stream.readArrayFloat32(uvMaps[i].uv);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readAttrMaps = function(stream, attrMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < attrMaps.length; ++ i){\n"+
	//magic "ATTR"
	"    stream.readInt32(); \n"+
	
	"    attrMaps[i].name = stream.readString();\n"+
	"    stream.readArrayFloat32(attrMaps[i].attr);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG1 = function(){\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.read = function(stream, body){\n"+
	"  this.readIndices(stream, body.indices);\n"+
	"  this.readVertices(stream, body.vertices);\n"+
	"  \n"+
	"  if (body.normals){\n"+
	"    this.readNormals(stream, body.normals);\n"+
	"  }\n"+
	"  if (body.uvMaps){\n"+
	"    this.readUVMaps(stream, body.uvMaps);\n"+
	"  }\n"+
	"  if (body.attrMaps){\n"+
	"    this.readAttrMaps(stream, body.attrMaps);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readIndices = function(stream, indices){\n"+
	//magic "INDX"
	"  stream.readInt32(); \n"+
	//packed size
	"  stream.readInt32(); \n"+
	"  \n"+
	"  var interleaved = new CTM.InterleavedStream(indices, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	
	"  CTM.restoreIndices(indices, indices.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readVertices = function(stream, vertices){\n"+
	//magic "VERT"
	"  stream.readInt32(); \n"+
	//packed size
	"  stream.readInt32(); \n"+
	"  \n"+
	"  var interleaved = new CTM.InterleavedStream(vertices, 1);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readNormals = function(stream, normals){\n"+
	//magic "NORM"
	"  stream.readInt32(); \n"+
	//packed size
	"  stream.readInt32(); \n"+
	
	"  var interleaved = new CTM.InterleavedStream(normals, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readUVMaps = function(stream, uvMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < uvMaps.length; ++ i){\n"+
	//magic "TEXC"
	"    stream.readInt32(); \n"+
	
	"    uvMaps[i].name = stream.readString();\n"+
	"    uvMaps[i].filename = stream.readString();\n"+
	"    \n"+
	//packed size
	"    stream.readInt32(); \n"+
	
	"    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readAttrMaps = function(stream, attrMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < attrMaps.length; ++ i){\n"+
	//magic "ATTR"
	"    stream.readInt32(); \n"+
	
	"    attrMaps[i].name = stream.readString();\n"+
	"    \n"+
	"    stream.readInt32(); //packed size\n"+
	
	"    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG2 = function(){\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.read = function(stream, body){\n"+
	"  this.MG2Header = new CTM.FileMG2Header(stream);\n"+
	"  \n"+
	"  this.readVertices(stream, body.vertices);\n"+
	"  this.readIndices(stream, body.indices);\n"+
	"  \n"+
	"  if (body.normals){\n"+
	"    this.readNormals(stream, body);\n"+
	"  }\n"+
	"  if (body.uvMaps){\n"+
	"    this.readUVMaps(stream, body.uvMaps);\n"+
	"  }\n"+
	"  if (body.attrMaps){\n"+
	"    this.readAttrMaps(stream, body.attrMaps);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readVertices = function(stream, vertices){\n"+
	//magic "VERT"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	
	"  var interleaved = new CTM.InterleavedStream(vertices, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  \n"+
	"  var gridIndices = this.readGridIndices(stream, vertices);\n"+
	"  \n"+
	"  CTM.restoreVertices(vertices, this.MG2Header, gridIndices, this.MG2Header.vertexPrecision);\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readGridIndices = function(stream, vertices){\n"+
	//magic "GIDX"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	"  \n"+
	"  var gridIndices = new Uint32Array(vertices.length / 3);\n"+
	"  \n"+
	"  var interleaved = new CTM.InterleavedStream(gridIndices, 1);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  \n"+
	"  CTM.restoreGridIndices(gridIndices, gridIndices.length);\n"+
	"  \n"+
	"  return gridIndices;\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readIndices = function(stream, indices){\n"+
	//magic "INDX"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	
	"  var interleaved = new CTM.InterleavedStream(indices, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	
	"  CTM.restoreIndices(indices, indices.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readNormals = function(stream, body){\n"+
	//magic "NORM"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	
	"  var interleaved = new CTM.InterleavedStream(body.normals, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	
	"  var smooth = CTM.calcSmoothNormals(body.indices, body.vertices);\n"+
	
	"  CTM.restoreNormals(body.normals, smooth, this.MG2Header.normalPrecision);\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readUVMaps = function(stream, uvMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < uvMaps.length; ++ i){\n"+
	//magic "TEXC"
	"    stream.readInt32(); \n"+
	
	"    uvMaps[i].name = stream.readString();\n"+
	"    uvMaps[i].filename = stream.readString();\n"+
	"    \n"+
	"    var precision = stream.readFloat32();\n"+
	"    \n"+
	"    stream.readInt32(); //packed size\n"+
	
	"    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"    \n"+
	"    CTM.restoreMap(uvMaps[i].uv, 2, precision);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readAttrMaps = function(stream, attrMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < attrMaps.length; ++ i){\n"+
	//magic "ATTR"
	"    stream.readInt32(); \n"+
	
	"    attrMaps[i].name = stream.readString();\n"+
	"    \n"+
	"    var precision = stream.readFloat32();\n"+
	"    \n"+
	"    stream.readInt32(); //packed size\n"+
	
	"    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"    \n"+
	"    CTM.restoreMap(attrMaps[i].attr, 4, precision);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreIndices = function(indices, len){\n"+
	"  var i = 3;\n"+
	"  if (len > 0){\n"+
	"    indices[2] += indices[0];\n"+
	"    indices[1] += indices[0];\n"+
	"  }\n"+
	"  for (; i < len; i += 3){\n"+
	"    indices[i] += indices[i - 3];\n"+
	"    \n"+
	"    if (indices[i] === indices[i - 3]){\n"+
	"      indices[i + 1] += indices[i - 2];\n"+
	"    }else{\n"+
	"      indices[i + 1] += indices[i];\n"+
	"    }\n"+
	
	"    indices[i + 2] += indices[i];\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreGridIndices = function(gridIndices, len){\n"+
	"  var i = 1;\n"+
	"  for (; i < len; ++ i){\n"+
	"    gridIndices[i] += gridIndices[i - 1];\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreVertices = function(vertices, grid, gridIndices, precision){\n"+
	"  var gridIdx, delta, x, y, z,\n"+
	"      intVertices = new Uint32Array(vertices.buffer, vertices.byteOffset, vertices.length),\n"+
	"      ydiv = grid.divx, zdiv = ydiv * grid.divy,\n"+
	"      prevGridIdx = 0x7fffffff, prevDelta = 0,\n"+
	"      i = 0, j = 0, len = gridIndices.length;\n"+
	
	"  for (; i < len; j += 3){\n"+
	"    x = gridIdx = gridIndices[i ++];\n"+
	"    \n"+
	"    z = ~~(x / zdiv);\n"+
	"    x -= ~~(z * zdiv);\n"+
	"    y = ~~(x / ydiv);\n"+
	"    x -= ~~(y * ydiv);\n"+
	
	"    delta = intVertices[j];\n"+
	"    if (gridIdx === prevGridIdx){\n"+
	"      delta += prevDelta;\n"+
	"    }\n"+
	
	"    vertices[j]     = grid.lowerBoundx +\n"+
	"      x * grid.sizex + precision * delta;\n"+
	"    vertices[j + 1] = grid.lowerBoundy +\n"+
	"      y * grid.sizey + precision * intVertices[j + 1];\n"+
	"    vertices[j + 2] = grid.lowerBoundz +\n"+
	"      z * grid.sizez + precision * intVertices[j + 2];\n"+
	
	"    prevGridIdx = gridIdx;\n"+
	"    prevDelta = delta;\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreNormals = function(normals, smooth, precision){\n"+
	"  var ro, phi, theta, sinPhi,\n"+
	"      nx, ny, nz, by, bz, len,\n"+
	"      intNormals = new Uint32Array(normals.buffer, normals.byteOffset, normals.length),\n"+
	"      i = 0, k = normals.length,\n"+
	"      PI_DIV_2 = 3.141592653589793238462643 * 0.5;\n"+
	
	"  for (; i < k; i += 3){\n"+
	"    ro = intNormals[i] * precision;\n"+
	"    phi = intNormals[i + 1];\n"+
	
	"    if (phi === 0){\n"+
	"      normals[i]     = smooth[i]     * ro;\n"+
	"      normals[i + 1] = smooth[i + 1] * ro;\n"+
	"      normals[i + 2] = smooth[i + 2] * ro;\n"+
	"    }else{\n"+
	"      \n"+
	"      if (phi <= 4){\n"+
	"        theta = (intNormals[i + 2] - 2) * PI_DIV_2;\n"+
	"      }else{\n"+
	"        theta = ( (intNormals[i + 2] * 4 / phi) - 2) * PI_DIV_2;\n"+
	"      }\n"+
	"      \n"+
	"      phi *= precision * PI_DIV_2;\n"+
	"      sinPhi = ro * Math.sin(phi);\n"+
	
	"      nx = sinPhi * Math.cos(theta);\n"+
	"      ny = sinPhi * Math.sin(theta);\n"+
	"      nz = ro * Math.cos(phi);\n"+
	
	"      bz = smooth[i + 1];\n"+
	"      by = smooth[i] - smooth[i + 2];\n"+
	
	"      len = Math.sqrt(2 * bz * bz + by * by);\n"+
	"      if (len > 1e-20){\n"+
	"        by /= len;\n"+
	"        bz /= len;\n"+
	"      }\n"+
	
	"      normals[i]     = smooth[i]     * nz +\n"+
	"        (smooth[i + 1] * bz - smooth[i + 2] * by) * ny - bz * nx;\n"+
	"      normals[i + 1] = smooth[i + 1] * nz -\n"+
	"        (smooth[i + 2]      + smooth[i]   ) * bz  * ny + by * nx;\n"+
	"      normals[i + 2] = smooth[i + 2] * nz +\n"+
	"        (smooth[i]     * by + smooth[i + 1] * bz) * ny + bz * nx;\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreMap = function(map, count, precision){\n"+
	"  var delta, value,\n"+
	"      intMap = new Uint32Array(map.buffer, map.byteOffset, map.length),\n"+
	"      i = 0, j, len = map.length;\n"+
	
	"  for (; i < count; ++ i){\n"+
	"    delta = 0;\n"+
	
	"    for (j = i; j < len; j += count){\n"+
	"      value = intMap[j];\n"+
	"      \n"+
	"      delta += value & 1? -( (value + 1) >> 1): value >> 1;\n"+
	"      \n"+
	"      map[j] = delta * precision;\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.calcSmoothNormals = function(indices, vertices){\n"+
	"  var smooth = new Float32Array(vertices.length),\n"+
	"      indx, indy, indz, nx, ny, nz,\n"+
	"      v1x, v1y, v1z, v2x, v2y, v2z, len,\n"+
	"      i, k;\n"+
	
	"  for (i = 0, k = indices.length; i < k;){\n"+
	"    indx = indices[i ++] * 3;\n"+
	"    indy = indices[i ++] * 3;\n"+
	"    indz = indices[i ++] * 3;\n"+
	
	"    v1x = vertices[indy]     - vertices[indx];\n"+
	"    v2x = vertices[indz]     - vertices[indx];\n"+
	"    v1y = vertices[indy + 1] - vertices[indx + 1];\n"+
	"    v2y = vertices[indz + 1] - vertices[indx + 1];\n"+
	"    v1z = vertices[indy + 2] - vertices[indx + 2];\n"+
	"    v2z = vertices[indz + 2] - vertices[indx + 2];\n"+
	"    \n"+
	"    nx = v1y * v2z - v1z * v2y;\n"+
	"    ny = v1z * v2x - v1x * v2z;\n"+
	"    nz = v1x * v2y - v1y * v2x;\n"+
	"    \n"+
	"    len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n"+
	"    if (len > 1e-10){\n"+
	"      nx /= len;\n"+
	"      ny /= len;\n"+
	"      nz /= len;\n"+
	"    }\n"+
	"    \n"+
	"    smooth[indx]     += nx;\n"+
	"    smooth[indx + 1] += ny;\n"+
	"    smooth[indx + 2] += nz;\n"+
	"    smooth[indy]     += nx;\n"+
	"    smooth[indy + 1] += ny;\n"+
	"    smooth[indy + 2] += nz;\n"+
	"    smooth[indz]     += nx;\n"+
	"    smooth[indz + 1] += ny;\n"+
	"    smooth[indz + 2] += nz;\n"+
	"  }\n"+
	
	"  for (i = 0, k = smooth.length; i < k; i += 3){\n"+
	"    len = Math.sqrt(smooth[i] * smooth[i] + \n"+
	"      smooth[i + 1] * smooth[i + 1] +\n"+
	"      smooth[i + 2] * smooth[i + 2]);\n"+
	
	"    if(len > 1e-10){\n"+
	"      smooth[i]     /= len;\n"+
	"      smooth[i + 1] /= len;\n"+
	"      smooth[i + 2] /= len;\n"+
	"    }\n"+
	"  }\n"+
	
	"  return smooth;\n"+
	"};\n"+
	
	"CTM.isLittleEndian = (function(){\n"+
	"  var buffer = new ArrayBuffer(2),\n"+
	"      bytes = new Uint8Array(buffer),\n"+
	"      ints = new Uint16Array(buffer);\n"+
	
	"  bytes[0] = 1;\n"+
	
	"  return ints[0] === 1;\n"+
	"}());\n"+
	
	"CTM.InterleavedStream = function(data, count){\n"+
	"  this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n"+
	"  this.offset = CTM.isLittleEndian? 3: 0;\n"+
	"  this.count = count * 4;\n"+
	"  this.len = this.data.length;\n"+
	"};\n"+
	
	"CTM.InterleavedStream.prototype.writeByte = function(value){\n"+
	"  this.data[this.offset] = value;\n"+
	"  \n"+
	"  this.offset += this.count;\n"+
	"  if (this.offset >= this.len){\n"+
	"  \n"+
	"    this.offset -= this.len - 4;\n"+
	"    if (this.offset >= this.count){\n"+
	"    \n"+
	"      this.offset -= this.count + (CTM.isLittleEndian? 1: -1);\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.Stream = function(data){\n"+
	"  this.data = data;\n"+
	"  this.offset = 0;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.TWO_POW_MINUS23 = Math.pow(2, -23);\n"+
	
	"CTM.Stream.prototype.TWO_POW_MINUS126 = Math.pow(2, -126);\n"+
	
	"CTM.Stream.prototype.readByte = function(){\n"+
	"  return this.data[this.offset ++] & 0xff;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readInt32 = function(){\n"+
	"  var i = this.readByte();\n"+
	"  i |= this.readByte() << 8;\n"+
	"  i |= this.readByte() << 16;\n"+
	"  return i | (this.readByte() << 24);\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readFloat32 = function(){\n"+
	"  var m = this.readByte();\n"+
	"  m += this.readByte() << 8;\n"+
	
	"  var b1 = this.readByte();\n"+
	"  var b2 = this.readByte();\n"+
	
	"  m += (b1 & 0x7f) << 16; \n"+
	"  var e = ( (b2 & 0x7f) << 1) | ( (b1 & 0x80) >>> 7);\n"+
	"  var s = b2 & 0x80? -1: 1;\n"+
	
	"  if (e === 255){\n"+
	"    return m !== 0? NaN: s * Infinity;\n"+
	"  }\n"+
	"  if (e > 0){\n"+
	"    return s * (1 + (m * this.TWO_POW_MINUS23) ) * Math.pow(2, e - 127);\n"+
	"  }\n"+
	"  if (m !== 0){\n"+
	"    return s * m * this.TWO_POW_MINUS126;\n"+
	"  }\n"+
	"  return s * 0;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readString = function(){\n"+
	"  var len = this.readInt32();\n"+
	
	"  this.offset += len;\n"+
	
	"  return String.fromCharCode.apply(null,this.data.subarray(this.offset - len, this.offset));\n"+
	//"  return this.offset - len + ' bis ' + len;\n  //String.fromCharCode.apply(null,this.data.subarray(this.offset - len, len));\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readArrayInt32 = function(array){\n"+
	"  var i = 0, len = array.length;\n"+
	"  \n"+
	"  while(i < len){\n"+
	"    array[i ++] = this.readInt32();\n"+
	"  }\n"+
	
	"  return array;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readArrayFloat32 = function(array){\n"+
	"  var i = 0, len = array.length;\n"+
	
	"  while(i < len){\n"+
	"    array[i ++] = this.readFloat32();\n"+
	"  }\n"+
	
	"  return array;\n"+
	"};\n"+
	
	
	"//original CTMWorker.js\n"+
	"self.onmessage = function( event ) {\n"+
	
	"	var files = [];\n"+
	
	"	for ( var i = 0; i < event.data.offsets.length; i ++ ) {\n"+
	
	"		var stream = new CTM.Stream( event.data.data );\n"+
	"		stream.offset = event.data.offsets[ i ];\n"+
	
	"		files[ i ] = new CTM.File( stream );\n"+
	
	"	}\n"+
	
	"	self.postMessage( files );\n"+
	"	self.close();\n"+
	
	"};";
